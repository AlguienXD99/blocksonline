<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>RETRO RETRO RETRO! – Evento BLOXPAST2D</title>
  <style>
    body { margin:0; padding:0; overflow:hidden; background:#222; font-family:Arial, sans-serif; color:white; }
    #gameCanvas { background:#2f2f3f; display:block; }
    #ui, #leaderboard, #minigame {
      position:absolute; background:rgba(0,0,0,0.7); padding:10px; border-radius:5px; font-size:14px;
    }
    #ui { bottom:20px; left:20px; }
    #leaderboard { top:20px; right:20px; width:150px; }
    #minigame { top:20px; left:20px; width:200px; }
    button { background:#444; color:white; border:none; padding:6px 10px; margin:4px; border-radius:3px; cursor:pointer; }
    button:hover { background:#666; }
    canvas { width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="leaderboard">Leaderboard<br>Loading...</div>
<div id="ui">
  Blocksgold: <span id="bgCount">0</span><br>
  <button onclick="startMinigame()">Iniciar Minijuego</button>
</div>
<div id="minigame" style="display:none;">
  <div id="mgTitle"></div>
  <div id="mgContent"></div>
  <button id="mgAction">¡Jugar!</button>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
import { getDatabase, ref, onValue, set, update, get, child } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyBuWcUaYo9eah5mehCQ0h8bBnkE_251NKY",
  authDomain: "virtualblocks-b7a52.firebaseapp.com",
  databaseURL: "https://virtualblocks-b7a52-default-rtdb.firebaseio.com",
  projectId: "virtualblocks-b7a52",
  storageBucket: "virtualblocks-b7a52.firebasestorage.app",
  messagingSenderId: "490618182453",
  appId: "1:490618182453:web:93385819c7ff08537d8a7c"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;
  
const playersRef = ref(db, "players2");
let players = {}, me = {
  id: null, x: 100, y: 100,
  color: "#888", nickname: "Anon",
  avatarConfig: {}, equippedItems: {}
};
let targetX = me.x, targetY = me.y;
const speed = 3;
let currentMini = null;

// Movimiento
addEventListener("mousemove", e => {
  targetX = e.clientX;
  targetY = e.clientY;
});
addEventListener("keydown", e => {
  if (e.key === "e" && me.id) toggleEquip();
});

let userRefPath = null;
let selfRef = null;
// Firebase Auth y carga de datos
onAuthStateChanged(auth, async user => {
  if (!user) return;

  me.id = user.uid;
  userRefPath = ref(db, `users/${me.id}`);
  selfRef = ref(db, `players2/${me.id}`);

  // Guardar o inicializar datos del usuario
  const snap = await get(userRefPath);
  if (!snap.exists()) {
    await set(userRefPath, {
      blocksgold: 0,
      avatarConfig: {},
      equippedItems: {},
      nickname: user.displayName || "Anon",
      isConnectedToGame1: true
    });
  } else {
    const data = snap.val();
    me.blocksgold = data.blocksgold || 0;
    me.nickname = data.nickname || (user.displayName || "Anon");
    me.avatarConfig = data.avatarConfig || {};
    me.equippedItems = data.equippedItems || {};
  }

  document.getElementById("bgCount").innerText = me.blocksgold;

  // Actualizar posición inicial
  await update(selfRef, {
    x: me.x,
    y: me.y,
    nickname: me.nickname,
    avatarConfig: me.avatarConfig || {},
    equippedItems: me.equippedItems || {}
  });
// después del update(selfRef, {...})
players[me.id] = {
  x: me.x,
  y: me.y,
  nickname: me.nickname,
  avatarConfig: me.avatarConfig || {},
  equippedItems: me.equippedItems || {}
};
updateLeaderboard();
});

onValue(ref(db, 'players2'), async snap => {
  try {
    const data = snap.val();
    const uids = Object.keys(data || {}).filter(uid => uid && uid !== "undefined" && typeof uid === 'string');
    const nicknamePromises = uids.map(async (uid) => {
      if (!uid || uid === "undefined") return;
      try {
        const userSnap = await get(child(ref(db), `users/${uid}`));
        const userData = userSnap.exists() ? userSnap.val() : {};

        players[uid] = players[uid] || {};
        players[uid] = {
          ...players[uid],
          ...data[uid],
          nickname: userData.nickname || uid,
          avatarConfig: userData.avatarConfig || {},
          equippedItems: userData.equippedItems || {}
        };
      } catch(e) {
        console.warn("Error fetching user data for uid", uid, e);
      }
    });

    await Promise.all(nicknamePromises);
    updateLeaderboard();

  } catch(e) {
    console.error("Error en onValue players:", e);
  }
});

setInterval(() => {
  if (selfRef && userRefPath) {
    update(selfRef, { x: me.x, y: me.y }).catch(console.warn);
    update(userRefPath, { blocksgold: (typeof me.blocksgold === 'number' ? me.blocksgold : 0) }).catch(console.warn);
  }
}, 500);

// Render
function render() {
  const size = 40;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let uid in players) {
    const p = players[uid] || {};
    const px = (typeof p.x === 'number') ? p.x : (uid === me.id ? me.x : 0);
    const py = (typeof p.y === 'number') ? p.y : (uid === me.id ? me.y : 0);
    const cfg = (uid === me.id) ? (me.avatarConfig || {}) : (p.avatarConfig || {});
    const gear = (uid === me.id) ? (me.equippedItems || {}) : (p.equippedItems || {});

    // Dibuja avatar CON SUS COLORES (drawAvatarOverlay usa defaults si faltan)
    drawAvatarOverlay(px, py, cfg, gear);

    // Texto encima del avatar
    ctx.fillStyle = "#fff";
    ctx.font = "12px Arial";
    ctx.textAlign = "center";
    const name = p.nickname || (uid === me.id ? me.nickname : uid);
    ctx.fillText(name, px, py - size * 2.6);
  }

  if (currentMini && currentMini.drawZone) currentMini.drawZone();

  updatePosition();
  requestAnimationFrame(render);
}
render();

function updatePosition() {
  const dx = targetX - me.x;
  const dy = targetY - me.y;
  const dist = Math.hypot(dx, dy);
  if (dist > 1) {
    me.x += dx / dist * speed;
    me.y += dy / dist * speed;
  }
}

const itemImages = {}; // Cache de imágenes

function getItemImage(url) {
  if (!itemImages[url]) {
    const img = new Image();
    img.src = url;
    itemImages[url] = img;
  }
  return itemImages[url];
}

function drawAvatarOverlay(x, y, config, equipped) {
  const size = 40;
  const headSize = 28;

  const offs = {
    head: [0, -1.1 * size],
    torso: [0, 0],
    leftArm: [-0.6 * size, 0],
    rightArm: [0.6 * size, 0],
    leftLeg: [-0.25 * size, 1.2 * size],
    rightLeg: [0.25 * size, 1.2 * size]
  };

  const sizes = {
    head: [headSize, headSize],
    torso: [size * 0.9, size * 1.2],
    leftArm: [size * 0.35, size * 1.1],
    rightArm: [size * 0.35, size * 1.1],
    leftLeg: [size * 0.32, size * 1.15],
    rightLeg: [size * 0.32, size * 1.15]
  };

  const renderOrder = ["leftLeg", "rightLeg", "torso", "leftArm", "rightArm", "head"];
  for (let part of renderOrder) {
    const [dx, dy] = offs[part];
    const [w, h] = sizes[part];
    ctx.fillStyle = config[part] || "#555";
    ctx.fillRect(x + dx - w / 2, y + dy, w, h);
  }

  const itemPositions = {
    head: [0, -1.1 * size],
    torso: [0, 0],
    leftArm: [-0.6 * size - 20, 0],
    rightArm: [0.6 * size + 10, 0],
    leftLeg: [-0.25 * size, 1.2 * size + 10],
    rightLeg: [0.25 * size, 1.2 * size + 10],
    back: [0, 10]
  };

  // Dibuja cada ítem equipado
  for (let key in equipped) {
    const item = equipped[key];
    if (!item || !item.imageUrl) continue;

    const img = getItemImage(item.imageUrl); // precarga/reusa la imagen
    const pos = item.position || "torso";
    const [offsetX, offsetY] = itemPositions[pos] || [0, 0];

    // Solo dibuja si la imagen ya tiene width/height (ya cargó)
    if (img.naturalWidth) {
      ctx.drawImage(img, x + offsetX - 15, y + offsetY, 30, 30);
    }
  }
}

function updateLeaderboard() {
  let html = "<b>Players</b><br>";
  for (let uid in players) {
    html += (players[uid].nickname || uid) + "<br>";
  }
  document.getElementById("leaderboard").innerHTML = html;
}

// MINIJUEGOS
const minigames = {
  colorTile: {
    title: "Pisa el color correcto",
    start() {
      document.getElementById("minigame").style.display = "block";
      document.getElementById("mgTitle").innerText = this.title;
      document.getElementById("mgContent").innerHTML = `Presiona <b>ESPACIO</b> solo si estás sobre el <span style="color: red;">cuadro rojo</span>.`;
      document.getElementById("mgAction").onclick = () => {
        const p = players[me.id];
        const inside = p && p.x > 300 && p.x < 400 && p.y > 200 && p.y < 300;
        reward(inside ? 10 : 0);
        endMini();
      };
    },
    drawZone() {
      ctx.strokeStyle = "red";
      ctx.strokeRect(300, 200, 100, 100);
    }
  }
};

function startMinigame() {
  if (currentMini) return;
  currentMini = minigames.colorTile;
  currentMini.start();
}

function reward(amount) {
  if (amount > 0) {
    me.blocksgold += amount;
   showToast(`¡Ganaste ${amount} BLOCKSGOLD!`);
  } else {
    showToast("Fallaste, sigue intentando.");
  }
}

function endMini() {
  currentMini = null;
  document.getElementById("minigame").style.display = "none";
}

function showToast(msg) {
  const div = document.createElement("div");
  div.innerText = msg;
  Object.assign(div.style, {
    position: "fixed", bottom: "50px", left: "50%",
    transform: "translateX(-50%)", background: "#333",
    color: "#fff", padding: "10px", borderRadius: "5px",
    zIndex: "9999"
  });
  document.body.appendChild(div);
  setTimeout(() => div.remove(), 2000);
}
</script>
</body>
</html>
