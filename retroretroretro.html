<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>RETRO RETRO RETRO! – Evento BLOXPAST2D</title>
  <style>
    body { margin:0; padding:0; overflow:hidden; background:#222; font-family:Arial, sans-serif; color:white; }
    #gameCanvas { background:#2f2f3f; display:block; }
    #ui, #leaderboard, #minigame {
      position:absolute; background:rgba(0,0,0,0.7); padding:10px; border-radius:5px; font-size:14px;
    }
    #ui { bottom:20px; left:20px; }
    #leaderboard { top:20px; right:20px; width:150px; }
    #minigame { top:20px; left:20px; width:200px; }
    button { background:#444; color:white; border:none; padding:6px 10px; margin:4px; border-radius:3px; cursor:pointer; }
    button:hover { background:#666; }
    canvas { width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="leaderboard">Leaderboard<br>Loading...</div>
<div id="ui">
  Blocksgold: <span id="bgCount">0</span><br>
  <button onclick="startMinigame()">Iniciar Minijuego</button>
</div>
<div id="minigame" style="display:none;">
  <div id="mgTitle"></div>
  <div id="mgContent"></div>
  <button id="mgAction">¡Jugar!</button>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
import { getDatabase, ref, onValue, set, update, get, child } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyBuWcUaYo9eah5mehCQ0h8bBnkE_251NKY",
  authDomain: "virtualblocks-b7a52.firebaseapp.com",
  databaseURL: "https://virtualblocks-b7a52-default-rtdb.firebaseio.com",
  projectId: "virtualblocks-b7a52",
  storageBucket: "virtualblocks-b7a52.firebasestorage.app",
  messagingSenderId: "490618182453",
  appId: "1:490618182453:web:93385819c7ff08537d8a7c"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;
  
const playersRef = ref(db, "players");
let players = {}, me = {
  id: null, x: 100, y: 100,
  color: "#888", nickname: "Anon",
  avatarConfig: {}, equippedItems: {}
};
let targetX = me.x, targetY = me.y;
const speed = 3;
let currentMini = null;

// Movimiento
addEventListener("mousemove", e => {
  targetX = e.clientX;
  targetY = e.clientY;
});
addEventListener("keydown", e => {
  if (e.key === "e" && me.id) toggleEquip();
});

  const userRefPath = ref(db, `users/${me.id}`);
  const selfRef = ref(db, `players/${me.id}`); 
// Firebase Auth y carga de datos
onAuthStateChanged(auth, user => {
  if (!user) return;

  me.id = user.uid;

  update(selfRef, { x: me.x, y: me.y });

  update(userRefPath, { isConnectedToGame1: true });

  get(child(ref(db), `users/${me.id}/nickname`)).then(s => {
    if (s.exists()) me.nickname = s.val();
  });

get(userRefPath).then(snap => {
  if (!snap.exists()) {
    // Usuario nuevo: inicializa blocksgold en 0
    set(userRefPath, {
      blocksgold: 0,
      avatarConfig: {},
      equippedItems: {},
      nickname: user.displayName || "Anon"
    });
  } else {
    const data = snap.val();
    me.blocksgold = data.blocksgold || 0;
    me.nickname = data.nickname || "Anon";
    me.avatarConfig = data.avatarConfig || {};
    me.equippedItems = data.equippedItems || {};
    document.getElementById("bgCount").innerText = me.blocksgold; // Actualiza UI
  }
});

onValue(ref(db, 'players'), async snap => {
  try {
    const data = snap.val();
    const uids = Object.keys(data || {}).filter(uid => uid && typeof uid === 'string' && uid !== "undefined");
    const nicknamePromises = uids.map(async (uid) => {
      if (!uid) return;
      try {
        const userSnap = await get(child(ref(db), `users/${uid}`));
        const userData = userSnap.exists() ? userSnap.val() : {};

        players[uid] = players[uid] || {};
        players[uid] = {
          ...players[uid],
          ...data[uid],
          nickname: userData.nickname || uid,
          avatarConfig: userData.avatarConfig || {},
          equippedItems: userData.equippedItems || {}
        };
      } catch(e) {
        console.warn("Error fetching user data for uid", uid, e);
      }
    });

    await Promise.all(nicknamePromises);
    updateLeaderboard();

  } catch(e) {
    console.error("Error en onValue players:", e);
  }
});
});

setInterval(() => {
  update(selfRef, { x: me.x, y: me.y });
  update(userRefPath, { blocksgold: (typeof me.blocksgold === 'number' ? me.blocksgold : 0) });
}, 500);

// Render
function render() {
  const size = 40; // <-- ¡Agrega esta línea!
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let uid in players) {
    const p = players[uid];
    ctx.fillStyle = p.avatarConfig?.torso || (uid === me.id ? "#ff0" : "#0f0");
    ctx.fillStyle = "#fff";
    ctx.font = "12px Arial";
    ctx.textAlign = "center";
    ctx.fillText(typeof p.nickname === "string" ? p.nickname : uid, p.x, p.y - size * 2.6);
    const cfg = uid === me.id ? me.avatarConfig : p.avatarConfig || {};
    const gear = uid === me.id ? me.equippedItems : p.equippedItems || {};
    drawAvatarOverlay(p.x, p.y, cfg, gear);
  }

  if (currentMini && currentMini.drawZone) {
    currentMini.drawZone();
  }

  updatePosition();
  requestAnimationFrame(render);
}
render();

function updatePosition() {
  const dx = targetX - me.x;
  const dy = targetY - me.y;
  const dist = Math.hypot(dx, dy);
  if (dist > 1) {
    me.x += dx / dist * speed;
    me.y += dy / dist * speed;
  }
}

function drawAvatarOverlay(x, y, config, equipped) {
  const size = 40;
  const headSize = 28;

  // Define posiciones base para cada "position" que uses en los ítems
  const itemPositions = {
    head: [0, -1.1 * size - 30],       // un poco arriba de la cabeza
    torso: [0, 0],                    // sobre el torso
    leftArm: [-0.6 * size - 20, 0],  // a la izquierda del brazo izquierdo
    rightArm: [0.6 * size + 10, 0],  // a la derecha del brazo derecho
    leftLeg: [-0.25 * size, 1.2 * size + 10],
    rightLeg: [0.25 * size, 1.2 * size + 10],
    back: [0, 10],                   // detrás del torso
    // Puedes agregar más posiciones según tu necesidad
  };

  const sizes = {
    head: [headSize, headSize],
    torso: [size * 0.9, size * 1.2],
    leftArm: [size * 0.35, size * 1.1],
    rightArm: [size * 0.35, size * 1.1],
    leftLeg: [size * 0.32, size * 1.15],
    rightLeg: [size * 0.32, size * 1.15]
  };

  const offs = {
    head: [0, -1.1 * size],
    torso: [0, 0],
    leftArm: [-0.6 * size, 0],
    rightArm: [0.6 * size, 0],
    leftLeg: [-0.25 * size, 1.2 * size],
    rightLeg: [0.25 * size, 1.2 * size]
  };

  // Dibuja partes del avatar
  const renderOrder = ["leftLeg", "rightLeg", "torso", "leftArm", "rightArm", "head"];
  for (let part of renderOrder) {
    const [dx, dy] = offs[part];
    const [w, h] = sizes[part];
    ctx.fillStyle = config[part] || "#555";
    ctx.fillRect(x + dx - w / 2, y + dy, w, h);
  }

  // Dibuja ítems equipados según su posición
  for (let key in equipped) {
    const item = equipped[key];
    if (!item || !item.imageUrl) continue;

    const pos = item.position || "torso"; // default a torso si no hay posición

    const [offsetX, offsetY] = itemPositions[pos] || [0, 0];
    const imgX = x + offsetX - 15; // ajusta el centro de la imagen
    const imgY = y + offsetY;

    const img = new Image();
    img.src = item.imageUrl;
    img.onload = () => {
      ctx.drawImage(img, imgX, imgY, 30, 30);
    };
  }
}

function updateLeaderboard() {
  let html = "<b>Players</b><br>";
  for (let uid in players) {
    html += (players[uid].nickname || uid) + "<br>";
  }
  document.getElementById("leaderboard").innerHTML = html;
}

// MINIJUEGOS
const minigames = {
  colorTile: {
    title: "Pisa el color correcto",
    start() {
      document.getElementById("minigame").style.display = "block";
      document.getElementById("mgTitle").innerText = this.title;
      document.getElementById("mgContent").innerHTML = `Presiona <b>ESPACIO</b> solo si estás sobre el <span style="color: red;">cuadro rojo</span>.`;
      document.getElementById("mgAction").onclick = () => {
        const p = players[me.id];
        const inside = p && p.x > 300 && p.x < 400 && p.y > 200 && p.y < 300;
        reward(inside ? 10 : 0);
        endMini();
      };
    },
    drawZone() {
      ctx.strokeStyle = "red";
      ctx.strokeRect(300, 200, 100, 100);
    }
  }
};

function startMinigame() {
  if (currentMini) return;
  currentMini = minigames.colorTile;
  currentMini.start();
}

function reward(amount) {
  if (amount > 0) {
    me.blocksgold += amount;
   showToast(`¡Ganaste ${amount} BLOCKSGOLD!`);
  } else {
    showToast("Fallaste, sigue intentando.");
  }
}

function endMini() {
  currentMini = null;
  document.getElementById("minigame").style.display = "none";
}

function showToast(msg) {
  const div = document.createElement("div");
  div.innerText = msg;
  Object.assign(div.style, {
    position: "fixed", bottom: "50px", left: "50%",
    transform: "translateX(-50%)", background: "#333",
    color: "#fff", padding: "10px", borderRadius: "5px",
    zIndex: "9999"
  });
  document.body.appendChild(div);
  setTimeout(() => div.remove(), 2000);
}
</script>
</body>
</html>
