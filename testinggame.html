
<!DOCTYPE html> 
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singleplayer Blockbase - Virtualblocks</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            height: 100%; 
            background-color: #87CEEB; /* Fondo azul cielo */
        }

        canvas { 
            display: block; 
        }

        /* Estilos para los botones de control */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
        }

        .control-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            margin: 5px;
        }

        /* Botones de control (Izquierda, Derecha, Arriba, Abajo, Salto) */
        #moveLeft { float: left; }
        #moveRight { float: right; }
        #moveUp { clear: both; }
        #moveDown { float: left; }

        /* Estilos para el botón de reportar */
        #reportButton {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            padding: 10px 20px;
            background-color: #ff6347;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        /* Estilos para el formulario de reporte */
        #reportForm {
            position: absolute;
            top: 50px;
            left: 10px;
            z-index: 1000;
            display: none;
            background-color: white;
            padding: 20px;
            border: 1px solid #000;
            border-radius: 5px;
        }

        #reportDescription {
            width: 300px;
            height: 100px;
        }

        button {
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:disabled {
            background-color: #ccc;
        }
    </style>
</head>
<body>
    <audio autoplay loop muted>
    <source src="https://gitlab.com/AlguienXD99/createfuntv/-/raw/main/punch.mp3" type="audio/mp3">
    Tu navegador no soporta el elemento de audio.
    </audio>
    <button onclick="window.close();">Salir del juego</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Configuración básica de Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Agregar luces
        const ambientLight = new THREE.AmbientLight(0x404040); // Luz suave
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Luz direccional
        directionalLight.position.set(5, 10, 5).normalize();
        scene.add(ambientLight);
        scene.add(directionalLight);

        // Crear el plano del suelo (baseplate)
        const baseplateGeometry = new THREE.PlaneGeometry(100, 100);
        const baseplateMaterial = new THREE.MeshLambertMaterial({ color: 0x808080, side: THREE.DoubleSide });
        const baseplate = new THREE.Mesh(baseplateGeometry, baseplateMaterial);
        baseplate.rotation.x = - Math.PI / 2;
        baseplate.position.y = -1;
        scene.add(baseplate);

        // Crear skybox (Fondo)
        const loader = new THREE.CubeTextureLoader();
        const skyboxTexture = loader.load([ 
            'skybox.png', 
            'skybox.png', 
            'skybox.png', 
            'skybox.png', 
            'skybox.png', 
            'skybox.png' 
        ]);
        scene.background = skyboxTexture;

        // Crear cuerpo del personaje (cabeza, torso, piernas)
        const bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
        const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const legsGeometry = new THREE.BoxGeometry(0.8, 1, 1);
        const armsGeometry = new THREE.BoxGeometry(0.5, 1.5, 2);

        // Materiales iniciales
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: '#00ff00' });
        let headMaterial = new THREE.MeshBasicMaterial({ color: '#f0f0f0' }); // Color predeterminado
        const legsMaterial = new THREE.MeshLambertMaterial({ color: '#ff0000' });
        const armsMaterial = new THREE.MeshLambertMaterial({ color: '#ff0000' });

        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.set(0, 1, 0);

        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.set(0, 2.3, 0);

        const legs = new THREE.Mesh(legsGeometry, legsMaterial);
        legs.position.set(0, -0.5, 0);
        
        const arms = new THREE.Mesh(armsGeometry, armsMaterial);
        arms.position.set(0, 1.2, 0);

        // Agrupar partes del cuerpo
        const player = new THREE.Group();
        player.add(body);
        player.add(head);
        player.add(legs);
        player.add(arms);
        scene.add(player);

        // Cargar la textura desde localStorage al cargar la página
        const textureLoader = new THREE.TextureLoader();

        // Primero, carga la configuración de avatar (colores)
        function loadAvatarSettings() {
            const avatarSettings = JSON.parse(localStorage.getItem('avatarSettings')) || {};

            // Colores del torso y piernas
            if (avatarSettings.torsoColor) {
                bodyMaterial.color.set(avatarSettings.torsoColor);
            }

            if (avatarSettings.legsColor) {
                legsMaterial.color.set(avatarSettings.legsColor);
            }

            if (avatarSettings.armsColor) {
                armsMaterial.color.set(avatarSettings.armsColor);
            }

            // Color o textura de la cabeza
            if (avatarSettings.faceTexture) {
                textureLoader.load(
                    avatarSettings.faceTexture,
                    (texture) => {
                        headMaterial.map = texture;
                        headMaterial.needsUpdate = true;
                    },
                    undefined,
                    (error) => {
                        console.error('Error cargando la textura de la cara:', error);
                    }
                );
            } else if (avatarSettings.headColor) {
                headMaterial.map = null; // Elimina la textura si no se usa
                headMaterial.color.set(avatarSettings.headColor);
                headMaterial.needsUpdate = true;
            }
        }

        // Ejecutar la carga de la configuración del avatar
        loadAvatarSettings();

        // Función para cargar la textura de la cara si se ha establecido en localStorage
        let equipedFaceImage = localStorage.getItem("equippedFaceImage");

        if (equipedFaceImage) {
            textureLoader.load(equipedFaceImage, (texture) => {
                headMaterial.map = texture;
                headMaterial.needsUpdate = true;
            });
        } else {
            // Si no hay imagen guardada, cargar una imagen predeterminada
            textureLoader.load('face1.png', (texture) => {
                headMaterial.map = texture;
                headMaterial.needsUpdate = true;
            });
        }

        // Crear bloque que recarga la página al ser tocado
        const reloadBlockGeometry = new THREE.BoxGeometry(2, 2, 2);
        const reloadBlockMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
        const reloadBlock = new THREE.Mesh(reloadBlockGeometry, reloadBlockMaterial);
        reloadBlock.position.set(0, 2, -5); // Colócalo en la escena
        scene.add(reloadBlock);

        // Detectar la colisión del jugador con el bloque de recarga
        function detectCollision() {
            const playerBoundingBox = new THREE.Box3().setFromObject(player);
            const reloadBlockBoundingBox = new THREE.Box3().setFromObject(reloadBlock);

            if (playerBoundingBox.intersectsBox(reloadBlockBoundingBox)) {
                window.location.reload(); // Recargar la página
            }
        }

        // Configuración de cámara y controles
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.enableZoom = true;
        controls.enableRotate = true;

        // Variables de movimiento
        const speed = 0.1;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isJumping = false;
        let jumpHeight = 1;
        let originalY = player.position.y;
        let rotationSpeed = 0.05; // Velocidad de rotación

        // Enfriamiento del salto (Cooldown)
        let canJump = true; // Variable de enfriamiento para evitar saltos repetidos rápidamente

        // Eventos de teclado para movimiento y salto
        document.addEventListener('keydown', (event) => {
            if (event.key === 'w') moveForward = true;
            if (event.key === 's') moveBackward = true;
            if (event.key === 'a') moveLeft = true;
            if (event.key === 'd') moveRight = true;
            if (event.key === ' ') {
                if (!isJumping && canJump) {
                    isJumping = true;
                    canJump = false; // Evitar otro salto hasta que el cooldown termine
                    setTimeout(() => {
                        canJump = true; // Permitir saltar después de 1 segundo
                    }, 1000); // Cooldown de 1 segundo
                }
            }

            // Eventos para girar el personaje con las flechas
            if (event.key === 'ArrowLeft') player.rotation.y += rotationSpeed;
            if (event.key === 'ArrowRight') player.rotation.y -= rotationSpeed;
        });

        document.addEventListener('keyup', (event) => {
            if (event.key === 'w') moveForward = false;
            if (event.key === 's') moveBackward = false;
            if (event.key === 'a') moveLeft = false;
            if (event.key === 'd') moveRight = false;
        });

        // Función de actualización
        function update() {
            if (moveForward) player.position.z -= speed;
            if (moveBackward) player.position.z += speed;
            if (moveLeft) player.position.x -= speed;
            if (moveRight) player.position.x += speed;

            if (isJumping) {
                player.position.y += 0.1; // Salto
                if (player.position.y >= originalY + jumpHeight) {
                    isJumping = false;
                }
            } else if (player.position.y > originalY) {
                player.position.y -= 0.1; // Caída
            }

            detectCollision(); // Detectar si se toca el bloque de recarga
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        camera.position.z = 5;
        update();
    </script>
</body>
</html>
